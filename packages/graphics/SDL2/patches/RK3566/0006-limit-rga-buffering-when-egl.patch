diff -rupN SDL2-2.30.0.orig/src/video/kmsdrm/SDL_kmsdrmopengles.c SDL2-2.30.0/src/video/kmsdrm/SDL_kmsdrmopengles.c
--- SDL2-2.30.0.orig/src/video/kmsdrm/SDL_kmsdrmopengles.c	2024-02-03 11:28:45.509212112 +0000
+++ SDL2-2.30.0/src/video/kmsdrm/SDL_kmsdrmopengles.c	2024-02-03 11:39:16.953104142 +0000
@@ -30,11 +30,15 @@
 #include "SDL_kmsdrmopengles.h"
 #include "SDL_kmsdrmdyn.h"
 #include <errno.h>
+#include<stdbool.h>
 
 #ifndef EGL_PLATFORM_GBM_MESA
 #define EGL_PLATFORM_GBM_MESA 0x31D7
 #endif
 
+extern rga_info_t src_info;
+extern rga_info_t dst_info;
+
 /* EGL implementation of SDL OpenGL support */
 
 void KMSDRM_GLES_DefaultProfileConfig(_THIS, int *mask, int *major, int *minor)
@@ -93,6 +97,7 @@ int KMSDRM_GLES_SwapWindow(_THIS, SDL_Wi
     SDL_VideoData *viddata = ((SDL_VideoData *)_this->driverdata);
     KMSDRM_FBInfo *fb_info;
     int ret = 0;
+    struct gbm_bo* rga_buffer = NULL;
 
     /* Always wait for the previous issued flip before issuing a new one,
        even if you do async flips. */
@@ -143,10 +148,28 @@ int KMSDRM_GLES_SwapWindow(_THIS, SDL_Wi
     }
 
     /* Get an actual usable fb for the next front buffer. */
-    fb_info = KMSDRM_FBFromBO(_this, windata->next_bo);
-    if (!fb_info) {
-        SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not get a framebuffer");
-        return 0;
+    if (dispdata->orientation == 0) {
+      fb_info = KMSDRM_FBFromBO(_this, windata->next_bo);
+    } else {
+      if (src_info.fd) {
+          close(src_info.fd);
+      }
+      src_info.fd = KMSDRM_gbm_bo_get_fd(windata->next_bo);
+      dst_info.fd = viddata->rga_buffer_prime_fds[viddata->rga_buffer_index];
+      if (c_RkRgaBlit(&src_info, &dst_info, NULL) < 0) {
+          SDL_LogError(SDL_LOG_CATEGORY_VIDEO,
+              "Failed to rga blit\n");
+      }
+    
+      rga_buffer = viddata->rga_buffers[viddata->rga_buffer_index];
+      fb_info = KMSDRM_FBFromBO(_this, rga_buffer);
+
+      if (!fb_info) {
+          SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not get a framebuffer");
+          return 0;
+      }
+
+      viddata->rga_buffer_index = (viddata->rga_buffer_index + 1) % RGA_BUFFERS_MAX;
     }
 
     if (!windata->bo) {
